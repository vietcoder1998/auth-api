// Prompt Template Model
model PromptTemplate {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?  @db.Text
  content     String   @db.Text // The actual prompt template text
  type        String? // e.g. 'system', 'user', 'agent', 'instruction'
  metadata    String?  @db.Text // JSON metadata (tags, source, etc.)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  promptHistories PromptHistory[]

  @@map("prompt_template")
}

// AI Model table
model AIModel {
  id          String      @id @default(uuid())
  name        String      @unique
  description String?
  type        String // e.g. 'gpt', 'claude', 'gemini'
  platformId  String?
  platform    AIPlatform? @relation(fields: [platformId], references: [id])
  // Remove agentId and agent relation; AIModel is referenced by Agent
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  SSO         SSO[]
  agents       Agent[]

  @@map("ai_model")
}

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum MessageType {
  question
  answer
}

// CommandType for Command model
enum CommandType {
  execute
  query
  update
  create
  delete
  transform
  planning // <-- New type for planning commands
}

// AI Platform Model
model AIPlatform {
  id           String         @id @default(uuid())
  name         String         @unique
  description  String?        @db.Text
  endpoint     String? // API endpoint URL
  apiKeys      AIKey[]
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  agents       Agent[]
  conversations Conversation[]
  models       AIModel[]

  @@map("ai_platform")
}

// AI Key Model
model AIKey {
  id           String         @id @default(uuid())
  key          String         @unique @db.VarChar(255)
  name         String
  description  String?        @db.Text
  userId       String?
  user         User?          @relation(fields: [userId], references: [id])
  platformId   String?
  platform     AIPlatform?    @relation(fields: [platformId], references: [id])
  isActive     Boolean        @default(true)
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @default(now())
  billing      Billing[]
  agents       AIKeyAgent[]
  Conversation Conversation[]

  @@map("ai_key")
}

// Join table for AIKey <-> Agent (many-to-many)
model AIKeyAgent {
  id        String   @id @default(uuid())
  aiKeyId   String
  agentId   String
  aiKey     AIKey    @relation(fields: [aiKeyId], references: [id], onDelete: Cascade)
  agent     Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([aiKeyId, agentId])
  @@map("ai_key_agent")
}

// Billing Model (linked to AIKey)
model Billing {
  id             String        @id @default(uuid())
  aiKeyId        String
  aiKey          AIKey         @relation(fields: [aiKeyId], references: [id], onDelete: Cascade)
  amount         Float
  currency       String        @default("USD")
  description    String?       @db.Text
  status         String        @default("pending") // pending, paid, failed
  paidAt         DateTime?
  conversationId String?
  conversation   Conversation? @relation(fields: [conversationId], references: [id])
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  @@map("billing")
}

model Category {
  id        String   @id @default(uuid())
  name      String   @unique
  blogs     Blog[]
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  @@map("category")
}

model Blog {
  id         String   @id @default(uuid())
  title      String
  content    String   @db.Text
  date       DateTime @default(now())
  categoryId String
  category   Category @relation(fields: [categoryId], references: [id])
  author     String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now())

  @@map("blog")
}

model Label {
  id           String        @id @default(uuid())
  name         String        @unique
  color        String?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @default(now())
  description  String?
  entityLabels EntityLabel[]

  @@map("label")
}

model Notification {
  id           String                @id @default(uuid())
  message      String                @db.Text
  type         String? // info, error, warning, etc.
  templateId   String?
  template     NotificationTemplate? @relation(fields: [templateId], references: [id])
  errorPayload String?               @db.Text // JSON error payload
  userId       String?
  user         User?                 @relation(fields: [userId], references: [id])
  read         Boolean               @default(false)
  status       Int                   @default(1) // 1=active, 0=hidden/deleted
  createdAt    DateTime              @default(now())
  updatedAt    DateTime              @default(now())

  @@map("notification")
}

model Message {
  id             String         @id @default(uuid())
  conversationId String
  conversation   Conversation   @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender         String // 'user', 'agent', 'system'
  content        String         @db.Text
  metadata       String?        @db.Text
  tokens         Int?
  position       Int            @default(0)
  agentId        String?
  isError        Boolean        @default(false)
  type           MessageType    @default(question) // 'question' or 'answer'
  faqId          String?
  faq            Faq?           @relation(fields: [faqId], references: [id])
  createdAt      DateTime       @default(now())
  AgentMemory    AgentMemory[]
  promptHistory  PromptHistory[] // 1:n - One message can be referenced by many prompts

  @@index([conversationId, position])
  @@map("message")
}

model User {
  id            String         @id @default(uuid())
  email         String         @unique
  password      String
  nickname      String?
  roleId        String?
  role          Role?          @relation(fields: [roleId], references: [id])
  tokens        Token[]
  ssos          SSO[]
  loginHistory  LoginHistory[]
  logicHistory  LogicHistory[]
  apiKeys       ApiKey[] // API keys created by this user
  agents        Agent[] // AI agents owned by this user
  conversations Conversation[] // Conversations this user participated in
  logEntries    LogEntry[] // Log entries created by this user
  status        String         @default("active")
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  File          File[]
  Job           Job[]
  Notification  Notification[]
  AIKey         AIKey[]

  @@map("user")
}

model Role {
  id               String            @id @default(uuid())
  name             String            @unique
  description      String?
  permissions      Permission[]
  users            User[]
  permissionGroups PermissionGroup[] // 1:n relationship with permission groups
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @default(now())

  @@map("role")
}

model PermissionGroup {
  id          String       @id @default(uuid())
  name        String       @unique
  description String?
  permissions Permission[] // 1:n relationship with permissions
  roleId      String?      // n:1 relationship with role (removed @unique)
  role        Role?        @relation(fields: [roleId], references: [id], onDelete: Restrict)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @default(now())

  @@map("permission_group")
}

model Permission {
  id                String           @id @default(uuid())
  name              String           @unique
  description       String?
  category          String           @default("other")
  route             String?
  method            String?          // GET, POST, PUT, DELETE, PATCH
  roles             Role[]
  permissionGroupId String?
  permissionGroup   PermissionGroup? @relation(fields: [permissionGroupId], references: [id], onDelete: Restrict)
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @default(now())

  @@map("permission")
}

model Token {
  id               String   @id @default(uuid())
  userId           String
  accessToken      String   @unique @db.VarChar(500)
  refreshToken     String   @unique @db.VarChar(500)
  createdAt        DateTime @default(now())
  expiresAt        DateTime @default(now())
  refreshExpiresAt DateTime @default(now())
  user             User     @relation(fields: [userId], references: [id])

  @@map("token")
}

model MailTemplate {
  id        String   @id @default(uuid())
  name      String   @unique
  subject   String
  body      String   @db.Text
  active    Boolean  @default(true)
  mails     Mail[]
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  @@map("mail_template")
}

model NotificationTemplate {
  id           String         @id @default(uuid())
  name         String         @unique
  title        String
  body         String         @db.Text
  active       Boolean        @default(true)
  logicHistory LogicHistory[]
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @default(now())
  Notification Notification[]

  @@map("notification_template")
}

model Config {
  id    String @id @default(uuid())
  key   String @unique
  value String

  @@map("config")
}

model ApiKey {
  id          String  @id @default(uuid())
  name        String // Friendly name for the API key
  key         String  @unique @db.VarChar(255) // The actual API key
  description String? @db.Text
  userId      String? // Optional: associate with a user
  user        User?   @relation(fields: [userId], references: [id])

  // Access control
  isActive    Boolean @default(true)
  permissions String? @db.Text // JSON array of allowed permissions/scopes
  allowedIPs  String? @db.Text // JSON array of allowed IP addresses

  // Rate limiting
  rateLimit Int? @default(1000) // Requests per hour

  // Usage tracking
  usageCount Int       @default(0)
  lastUsedAt DateTime?

  // Expiration
  expiresAt DateTime?

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String? // User ID who created this API key

  // Usage logs
  apiUsageLogs ApiUsageLog[]

  @@map("api_key")
}

model ApiUsageLog {
  id       String @id @default(uuid())
  apiKeyId String
  apiKey   ApiKey @relation(fields: [apiKeyId], references: [id], onDelete: Cascade)

  // Request details
  endpoint  String // The API endpoint called
  method    String // HTTP method (GET, POST, etc.)
  ipAddress String?
  userAgent String? @db.Text

  // Response details
  statusCode   Int // HTTP status code
  responseTime Int? // Response time in milliseconds

  // Request/Response data (optional, for debugging)
  requestBody  String? @db.Text
  responseBody String? @db.Text

  // Metadata
  createdAt DateTime @default(now())

  @@map("api_usage_log")
}

model Mail {
  id           String        @id @default(uuid())
  to           String
  from         String?
  subject      String
  body         String        @db.Text
  status       String        @default("pending") // pending, sent, failed
  templateId   String?
  template     MailTemplate? @relation(fields: [templateId], references: [id])
  sentAt       DateTime?
  failedReason String?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @default(now())

  @@map("mail")
}

model SSO {
  id           String         @id @default(uuid())
  modelId      String?
  model        AIModel?       @relation(fields: [modelId], references: [id], onDelete: Cascade)
  url          String
  key          String         @unique
  ssoKey       String?        @unique // Additional SSO key field for identification
  userId       String
  deviceIP     String?
  loginHistory LoginHistory[]
  user         User           @relation(fields: [userId], references: [id])
  isActive     Boolean        @default(true)
  expiresAt    DateTime?
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @default(now())

  @@map("sso")
}

model LoginHistory {
  id        String    @id @default(uuid())
  ssoId     String?
  userId    String
  deviceIP  String?
  userAgent String?
  loginAt   DateTime  @default(now())
  logoutAt  DateTime?
  status    String    @default("active") // active, logged_out, expired
  location  String?
  sso       SSO?      @relation(fields: [ssoId], references: [id])
  user      User      @relation(fields: [userId], references: [id])
  createdAt DateTime  @default(now())
  updatedAt DateTime  @default(now())

  @@map("login_history")
}

model LogicHistory {
  id                     String                @id @default(uuid())
  userId                 String
  action                 String // login, logout, password_change, profile_update, etc.
  entityType             String? // user, role, permission, etc.
  entityId               String?
  oldValues              String?               @db.Text // JSON string of old values
  newValues              String?               @db.Text // JSON string of new values
  ipAddress              String?
  userAgent              String?
  notificationTemplateId String?
  notificationSent       Boolean               @default(false)
  user                   User                  @relation(fields: [userId], references: [id])
  notificationTemplate   NotificationTemplate? @relation(fields: [notificationTemplateId], references: [id])
  createdAt              DateTime              @default(now())

  @@map("logic_history")
}

// AI Agent Management Models
model Agent {
  id           String      @id @default(uuid())
  userId       String
  user         User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  name         String
  description  String?     @db.Text
  personality  String?     @db.Text // JSON config for personality
  systemPrompt String?     @db.Text
  config       String?     @db.Text // JSON config (temperature, max_tokens, etc.)
  isActive     Boolean     @default(true)
  platformId   String?
  platform     AIPlatform? @relation(fields: [platformId], references: [id])

  // Relationships
  memories      AgentMemory[]
  conversations Conversation[]
  tasks         AgentTask[]
  aiKeys        AIKeyAgent[]
  model         AIModel?       @relation(fields: [aIModelId], references: [id])
  tools         AgentTool[]

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())
  Faq       Faq[]
  aIModelId String?

  @@map("agent")
}

model Tool {
  id          String      @id @default(uuid())
  name        String      @unique
  description String?
  type        String // e.g. 'api', 'function', 'system', 'plugin'
  config      String?     @db.Text // JSON configuration for the tool
  enabled     Boolean     @default(true)
  commands    Command[]   @relation("ToolCommands") // 1:N Tool-Command, restrict on delete
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @default(now())
  agents      AgentTool[]

  toolContexts      ToolContext[] // 1:n relation to ToolContext
  Result            Result[]
  ToolExecuteResult ToolExecuteResult[]
  ToolCommand       ToolCommand[]

  @@map("tool")
}

// Context model
model Context {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now())

  toolContexts ToolContext[] // 1:n relation to ToolContext

  @@map("context")
}

// Join table for Tool <-> Context (many-to-one, cascade)
model ToolContext {
  id                String              @id @default(uuid())
  toolId            String
  contextId         String
  tool              Tool                @relation(fields: [toolId], references: [id], onDelete: Cascade)
  context           Context             @relation(fields: [contextId], references: [id], onDelete: Cascade)
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @default(now())
  ToolExplainResult ToolExplainResult[]

  @@unique([toolId, contextId])
  @@index([toolId])
  @@index([contextId])
  @@map("tool_context")
}

// Junction table for Agent <-> Tool (many-to-many)
model AgentTool {
  id        String   @id @default(uuid())
  agentId   String
  toolId    String
  agent     Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)
  tool      Tool     @relation(fields: [toolId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([agentId, toolId])
  @@map("agent_tool")
}

model Command {
  id            String       @id @default(uuid())
  toolId        String
  tool          Tool         @relation("ToolCommands", fields: [toolId], references: [id], onDelete: Restrict)
  name          String // Command name (e.g., 'git_commit', 'deploy', 'test')
  action        String // Action type (e.g., 'execute', 'query', 'update')
  type          CommandType? @default(execute) // <-- Add type field, default to execute
  repository    String? // Repository identifier or path
  script        String?      @db.Text // Script or command to execute
  params        String?      @db.Text // Deprecated: Use metadata field instead
  exampleParams String?      @db.Text // Deprecated: Use metadata field instead
  description   String?      @db.Text
  enabled       Boolean      @default(true)
  timeout       Int?         @default(30000) // Timeout in milliseconds
  retries       Int?         @default(0) // Number of retry attempts
  metadata      String?      @db.Text // JSON metadata for parameters and configuration
  // Example metadata structure:
  // {
  //   "permission": {
  //     "name": "Create permission",
  //     "route": "/api/permission", 
  //     "method": "POST"
  //   },
  //   "entity": {
  //     "permissionId": "{permission_id}",
  //     "userId": "{user_id}"
  //   },
  //   "steps": [
  //     {"tool": "DataFetcher", "command": "get_sales_data", "params": {"quarter": "Q3"}},
  //     {"tool": "Analyzer", "command": "calculate_growth"},
  //     {"tool": "Forecaster", "command": "predict_next_quarter"}
  //   ]
  // }
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @default(now())

  executions    CommandExecution[]
  Entity        Entity[]
  entityMethods CommandEntityMethod[] // Many-to-many relation with EntityMethod

  toolSteps ToolStep[] // 1:n relation to ToolStep

  @@unique([toolId, name])
  @@index([toolId])
  @@index([action])
  @@map("command")
}

// ToolStep model for planning steps
model ToolStep {
  id          String   @id @default(uuid())
  commandId   String
  command     Command  @relation(fields: [commandId], references: [id], onDelete: Cascade)
  stepIndex   Int // Order of the step in the plan
  tool        String // Tool name
  toolType    String? // Optional: type of tool
  commandName String // Command to execute
  params      String?  @db.Text // JSON params for the step
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now())

  @@index([commandId])
  @@map("tool_step")
}

model CommandExecution {
  id          String    @id @default(uuid())
  commandId   String
  command     Command   @relation(fields: [commandId], references: [id], onDelete: Cascade)
  status      String    @default("pending") // pending, running, completed, failed
  input       String?   @db.Text // JSON input parameters
  output      String?   @db.Text // JSON output/result
  error       String?   @db.Text // Error message if failed
  executedBy  String? // User or agent ID who executed
  duration    Int? // Execution duration in milliseconds
  startedAt   DateTime?
  completedAt DateTime?
  createdAt   DateTime  @default(now())

  @@index([commandId])
  @@index([status])
  @@index([createdAt])
  @@map("command_execution")
}

model AgentMemory {
  id             String         @id @default(uuid())
  agentId        String
  agent          Agent          @relation(fields: [agentId], references: [id], onDelete: Cascade)
  promptId       String?
  prompt         PromptHistory? @relation(fields: [promptId], references: [id])
  conversationId String?
  conversation   Conversation?  @relation(fields: [conversationId], references: [id])
  messageId      String?
  message        Message?       @relation(fields: [messageId], references: [id])
  type           String // 'short_term', 'long_term', 'knowledge_base'
  content        String         @db.Text
  vectorId       String? // <-- NEW: stores Redis vector key
  tokens         Int? // Token count for embedded message
  metadata       String?        @db.Text // JSON metadata (tags, source, date, etc.)
  importance     Int            @default(1) // 1-10 importance score
  createdAt      DateTime       @default(now())

  @@map("agent_memory")
}

model Conversation {
  id         String      @id @default(uuid())
  agentId    String
  agent      Agent       @relation(fields: [agentId], references: [id], onDelete: Cascade)
  userId     String
  user       User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  aiKeyId    String?
  aiKey      AIKey?      @relation(fields: [aiKeyId], references: [id])
  platformId String?
  platform   AIPlatform? @relation(fields: [platformId], references: [id])
  title      String?
  summary    String?     @db.Text
  isActive   Boolean     @default(true)

  messages      Message[]
  promptHistory PromptHistory[] // <-- Link to prompt history

  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @default(now())
  Faq             Faq[]
  JobConversation JobConversation[]
  Billing         Billing[]
  AgentMemory     AgentMemory[]

  @@map("conversation")
}

model PromptHistory {
  id             String   @id @default(uuid())
  conversationId String
  prompt         String   @db.Text // The prompt text
  messageId      String?  @unique // 1:1 relationship with Message
  message        Message? @relation(fields: [messageId], references: [id], onDelete: Cascade)
  createdAt      DateTime @default(now())

  Conversation     Conversation    @relation(fields: [conversationId], references: [id])
  Faq              Faq[]
  AgentMemory      AgentMemory[]
  PromptTemplate   PromptTemplate? @relation(fields: [promptTemplateId], references: [id])
  promptTemplateId String?

  @@index([conversationId])
  @@map("prompt_history")
}

model AgentTask {
  id        String    @id @default(uuid())
  agentId   String
  agent     Agent     @relation(fields: [agentId], references: [id], onDelete: Cascade)
  name      String
  input     String?   @db.Text // JSON input data
  output    String?   @db.Text // JSON output result
  status    String    @default("pending") // 'pending', 'running', 'completed', 'failed'
  error     String?   @db.Text
  startedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  @@map("agent_task")
}

// Single Generic Junction Table for Entity-Label Relationships
model EntityLabel {
  id         String @id @default(uuid())
  entityId   String // ID of any entity (user, role, permission, etc.)
  entityType String // Type of entity (user, role, permission, token, etc.)
  labelId    String
  label      Label  @relation(fields: [labelId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([entityId, entityType, labelId])
  @@index([entityId, entityType])
  @@index([labelId])
  @@index([entityType])
  @@map("entity_label")
}

// Database Connection Management
model DatabaseConnection {
  id          String  @id @default(uuid())
  name        String  @unique
  description String? @db.Text
  type        String // 'mysql', 'postgresql', 'mongodb', 'sqlite'
  host        String
  port        Int     @default(3306)
  database    String
  username    String
  password    String // Should be encrypted in production

  // Connection options
  ssl     Boolean @default(false)
  timeout Int     @default(30000) // Connection timeout in milliseconds
  options String? @db.Text // JSON string for additional connection options

  // Status and monitoring
  isActive   Boolean   @default(true)
  lastTested DateTime?
  testStatus String? // 'success', 'failed', 'pending'
  testError  String?   @db.Text

  // Backup settings
  backupEnabled Boolean   @default(false)
  backupPath    String?
  lastBackup    DateTime?

  // Metadata
  createdBy   String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @default(now())
  JobDatabase JobDatabase[]

  @@map("database_connection")
}

// Application Logs
model LogEntry {
  id           String   @id @default(uuid())
  level        String // 'error', 'warn', 'info', 'debug'
  message      String   @db.Text
  metadata     String?  @db.Text // JSON metadata
  userId       String?
  user         User?    @relation(fields: [userId], references: [id])
  ipAddress    String?
  userAgent    String?  @db.Text
  endpoint     String?
  method       String? // HTTP method
  statusCode   Int?
  responseTime Int? // Response time in milliseconds
  timestamp    DateTime @default(now())

  @@index([level])
  @@index([userId])
  @@index([timestamp])
  @@index([endpoint])
  @@map("log_entry")
}

model SocketConfig {
  id        String        @id @default(uuid())
  name      String
  host      String
  port      Int
  isActive  Boolean       @default(true)
  events    SocketEvent[]
  createdAt DateTime      @default(now())
  updatedAt DateTime      @default(now())

  @@map("socket_config")
}

model SocketEvent {
  id             String       @id @default(uuid())
  socketConfigId String
  type           String
  event          String
  socketConfig   SocketConfig @relation(fields: [socketConfigId], references: [id])
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @default(now())

  @@map("socket_event")
}

model File {
  id           String        @id @default(uuid())
  filename     String
  originalname String
  mimetype     String
  size         Int
  type         String        @default("document")
  path         String
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @default(now())
  User         User?         @relation(fields: [userId], references: [id])
  userId       String?
  JobDocument  JobDocument[]
  Document     Document?
}

model Document {
  id        String   @id @default(uuid())
  fileId    String   @unique
  file      File     @relation(fields: [fileId], references: [id], onDelete: Cascade)
  name      String?
  url       String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  job       Job?     @relation(fields: [jobId], references: [id])
  jobId     String?  @unique

  @@map("document")
}

model UiConfig {
  id        String   @id @default(uuid())
  name      String   @unique
  value     String   @db.Text
  role      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  @@map("ui_config")
}

model Faq {
  id             String         @id @default(uuid())
  question       String         @db.Text
  answer         String         @db.Text
  type           String         @default("manual") // agent, doc_input, manual
  promptId       String?
  prompt         PromptHistory? @relation(fields: [promptId], references: [id])
  conversationId String?
  conversation   Conversation?  @relation(fields: [conversationId], references: [id])
  aiAgentId      String?
  agent          Agent?         @relation(fields: [aiAgentId], references: [id])
  messages       Message[] // Link FAQ to messages (question/answer)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  description    String?

  @@map("faq")
}

model Job {
  id          String    @id @default(uuid())
  type        String    @default("backup") // backup, fine-tuning, extract, document, database, conversation, etc.
  status      String    @default("pending") // pending, running, completed, failed
  payload     String?   @db.Text // JSON string for job data
  result      String?   @db.Text // JSON string for job result/output
  error       String?   @db.Text
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  startedAt   DateTime?
  finishedAt  DateTime?
  description String?
  userId      String?
  user        User?     @relation(fields: [userId], references: [id])

  // Link to at least one conversation
  conversations JobConversation[]

  // Link to at least one document
  documents JobDocument[]

  // Link to at least one database
  databases JobDatabase[]

  document Document?

  @@map("job")
}

// Junction table for Job <-> Conversation (many-to-many)
model JobConversation {
  id             String       @id @default(uuid())
  jobId          String
  conversationId String
  job            Job          @relation(fields: [jobId], references: [id], onDelete: Cascade)
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  createdAt      DateTime     @default(now())

  @@unique([jobId, conversationId])
  @@index([jobId])
  @@index([conversationId])
  @@map("job_conversation")
}

// Blog and Category Models
// Junction table for Job <-> Document (many-to-many)
model JobDocument {
  id         String   @id @default(uuid())
  jobId      String
  documentId String
  job        Job      @relation(fields: [jobId], references: [id], onDelete: Cascade)
  document   File     @relation(fields: [documentId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())

  @@unique([jobId, documentId])
  @@index([jobId])
  @@index([documentId])
  @@map("job_document")
}

// Junction table for Job <-> Database (many-to-many)
model JobDatabase {
  id         String             @id @default(uuid())
  jobId      String
  databaseId String
  job        Job                @relation(fields: [jobId], references: [id], onDelete: Cascade)
  database   DatabaseConnection @relation(fields: [databaseId], references: [id], onDelete: Cascade)
  createdAt  DateTime           @default(now())

  @@unique([jobId, databaseId])
  @@index([jobId])
  @@index([databaseId])
  @@map("job_database")
}

model Entity {
  id          String         @id @default(uuid())
  name        String
  description String?
  commandId   String? //@db.Uuid
  command     Command?       @relation(fields: [commandId], references: [id], onDelete: Restrict)
  methods     EntityMethod[] // Relation: one Entity -> many EntityMethod
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  @@map("entity")
}

model EntityMethod {
  id          String                @id @default(uuid())
  name        String
  code        String?               @db.Text
  description String?
  entityId    String? // @db.Uuid
  entity      Entity?               @relation(fields: [entityId], references: [id], onDelete: Cascade)
  commands    CommandEntityMethod[] // Many-to-many relation with Command
  createdAt   DateTime              @default(now())
  updatedAt   DateTime              @updatedAt

  @@map("entity_method")
}

// Junction table for Command <-> EntityMethod (many-to-many)
model CommandEntityMethod {
  id             String       @id @default(uuid())
  commandId      String
  entityMethodId String
  command        Command      @relation(fields: [commandId], references: [id], onDelete: Cascade)
  entityMethod   EntityMethod @relation(fields: [entityMethodId], references: [id], onDelete: Cascade)
  createdAt      DateTime     @default(now())

  @@unique([commandId, entityMethodId])
  @@index([commandId])
  @@index([entityMethodId])
  @@map("command_entity_method")
}

// --- Added from UML diagram ---

enum ToolType {
  gen_context
  planner
  explainer
  adjust_execution
  execute
}

enum ResultType {
  tool_execute_result
  command_execute_result
  tool_explain_result
  adjust_tool_result
}

model Result {
  id         String      @id @default(uuid())
  content    String?     @db.Text
  toolId     String?
  tool       Tool?       @relation(fields: [toolId], references: [id])
  resultType ResultType?
  createdAt  DateTime    @default(now())

  @@map("result")
}

model ToolExecuteResult {
  id        String   @id @default(uuid())
  toolId    String
  tool      Tool     @relation(fields: [toolId], references: [id])
  result    String?  @db.Text
  createdAt DateTime @default(now())

  @@map("tool_execute_result")
}

model ToolCommand {
  id        String   @id @default(uuid())
  toolId    String
  tool      Tool     @relation(fields: [toolId], references: [id])
  name      String
  createdAt DateTime @default(now())

  @@map("tool_command")
}

model ToolExplainResult {
  id            String      @id @default(uuid())
  toolContextId String
  toolContext   ToolContext @relation(fields: [toolContextId], references: [id])
  result        String?     @db.Text
  createdAt     DateTime    @default(now())

  @@map("tool_explain_result")
}

// --- Extend existing models with new fields/relations ---

// Tool: add toolType, toolSteps, toolExecuteResult, toolCommands, conversations, agentsDirect
// ToolStep: add toolId, toolRef, toolExecuteResult
// ToolContext: add toolExplainResult, promptId, prompt, goal
// Agent: add toolsDirect
// Conversation: add toolId, tool

// NOTE: These should be manually merged into the respective models above for best practice.
