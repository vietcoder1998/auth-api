generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum MessageType {
  question
  answer
}

model Label {
  id    String   @id @default(uuid())
  name  String   @unique
  color String?
  createdAt DateTime @default(now())  
  updatedAt DateTime @updatedAt
  description String?
  entityLabels EntityLabel[]
  @@map("label")
}


model Message {
  id              String         @id @default(uuid())
  conversationId  String
  conversation    Conversation   @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender          String // 'user', 'agent', 'system'
  content         String         @db.Text
  metadata        String?        @db.Text
  tokens          Int?
  position        Int            @default(0)
  agentId         String?
  isError         Boolean        @default(false)
  promptHistoryId String? // <-- Reference to PromptHistory
  promptHistory   PromptHistory? @relation(fields: [promptHistoryId], references: [id])
  type            MessageType    @default(question) // 'question' or 'answer'
  faqId           String?
  faq             Faq?           @relation(fields: [faqId], references: [id])
  createdAt       DateTime       @default(now())

  @@index([conversationId, position])
  @@map("message")
}

model User {
  id            String         @id @default(uuid())
  email         String         @unique
  password      String
  nickname      String?
  roleId        String?
  role          Role?          @relation(fields: [roleId], references: [id])
  tokens        Token[]
  ssos          SSO[]
  loginHistory  LoginHistory[]
  logicHistory  LogicHistory[]
  apiKeys       ApiKey[] // API keys created by this user
  agents        Agent[] // AI agents owned by this user
  conversations Conversation[] // Conversations this user participated in
  logEntries    LogEntry[] // Log entries created by this user
  status        String         @default("active")
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  File          File[]

  @@map("user")
}

model Role {
  id          String       @id @default(uuid())
  name        String       @unique
  description String?
  permissions Permission[]
  users       User[]
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  @@map("role")
}

model Permission {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?
  category    String   @default("other")
  route       String?
  method      String? // GET, POST, PUT, DELETE, PATCH
  roles       Role[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now())

  @@map("permission")
}

model Token {
  id           String   @id @default(uuid())
  userId       String
  accessToken  String   @unique @db.VarChar(500)
  refreshToken String   @unique @db.VarChar(500)
  createdAt    DateTime @default(now())
  expiresAt    DateTime
  user         User     @relation(fields: [userId], references: [id])

  @@map("token")
}

model MailTemplate {
  id        String   @id @default(uuid())
  name      String   @unique
  subject   String
  body      String   @db.Text
  active    Boolean  @default(true)
  mails     Mail[]
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  @@map("mail_template")
}

model NotificationTemplate {
  id           String         @id @default(uuid())
  name         String         @unique
  title        String
  body         String         @db.Text
  active       Boolean        @default(true)
  logicHistory LogicHistory[]
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @default(now())

  @@map("notification_template")
}

model Config {
  id    String @id @default(uuid())
  key   String @unique
  value String

  @@map("config")
}

model ApiKey {
  id          String  @id @default(uuid())
  name        String // Friendly name for the API key
  key         String  @unique @db.VarChar(255) // The actual API key
  description String? @db.Text
  userId      String? // Optional: associate with a user
  user        User?   @relation(fields: [userId], references: [id])

  // Access control
  isActive    Boolean @default(true)
  permissions String? @db.Text // JSON array of allowed permissions/scopes
  allowedIPs  String? @db.Text // JSON array of allowed IP addresses

  // Rate limiting
  rateLimit Int? @default(1000) // Requests per hour

  // Usage tracking
  usageCount Int       @default(0)
  lastUsedAt DateTime?

  // Expiration
  expiresAt DateTime?

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String? // User ID who created this API key

  // Usage logs
  apiUsageLogs ApiUsageLog[]

  @@map("api_key")
}

model ApiUsageLog {
  id       String @id @default(uuid())
  apiKeyId String
  apiKey   ApiKey @relation(fields: [apiKeyId], references: [id], onDelete: Cascade)

  // Request details
  endpoint  String // The API endpoint called
  method    String // HTTP method (GET, POST, etc.)
  ipAddress String?
  userAgent String? @db.Text

  // Response details
  statusCode   Int // HTTP status code
  responseTime Int? // Response time in milliseconds

  // Request/Response data (optional, for debugging)
  requestBody  String? @db.Text
  responseBody String? @db.Text

  // Metadata
  createdAt DateTime @default(now())

  @@map("api_usage_log")
}

model Mail {
  id           String        @id @default(uuid())
  to           String
  from         String?
  subject      String
  body         String        @db.Text
  status       String        @default("pending") // pending, sent, failed
  templateId   String?
  template     MailTemplate? @relation(fields: [templateId], references: [id])
  sentAt       DateTime?
  failedReason String?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @default(now())

  @@map("mail")
}

model SSO {
  id           String         @id @default(uuid())
  url          String
  key          String         @unique
  ssoKey       String?        @unique // Additional SSO key field for identification
  userId       String
  deviceIP     String?
  loginHistory LoginHistory[]
  user         User           @relation(fields: [userId], references: [id])
  isActive     Boolean        @default(true)
  expiresAt    DateTime?
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @default(now())

  @@map("sso")
}

model LoginHistory {
  id        String    @id @default(uuid())
  ssoId     String?
  userId    String
  deviceIP  String?
  userAgent String?
  loginAt   DateTime  @default(now())
  logoutAt  DateTime?
  status    String    @default("active") // active, logged_out, expired
  location  String?
  sso       SSO?      @relation(fields: [ssoId], references: [id])
  user      User      @relation(fields: [userId], references: [id])
  createdAt DateTime  @default(now())
  updatedAt DateTime  @default(now())

  @@map("login_history")
}

model LogicHistory {
  id                     String                @id @default(uuid())
  userId                 String
  action                 String // login, logout, password_change, profile_update, etc.
  entityType             String? // user, role, permission, etc.
  entityId               String?
  oldValues              String?               @db.Text // JSON string of old values
  newValues              String?               @db.Text // JSON string of new values
  ipAddress              String?
  userAgent              String?
  notificationTemplateId String?
  notificationSent       Boolean               @default(false)
  user                   User                  @relation(fields: [userId], references: [id])
  notificationTemplate   NotificationTemplate? @relation(fields: [notificationTemplateId], references: [id])
  createdAt              DateTime              @default(now())

  @@map("logic_history")
}

// AI Agent Management Models
model Agent {
  id           String  @id @default(uuid())
  userId       String
  user         User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  name         String
  description  String? @db.Text
  model        String  @default("gpt-4") // LLM model (gpt-4, claude-3, etc.)
  personality  String? @db.Text // JSON config for personality
  systemPrompt String? @db.Text
  config       String? @db.Text // JSON config (temperature, max_tokens, etc.)
  isActive     Boolean @default(true)

  // Relationships
  memories      AgentMemory[]
  conversations Conversation[]
  tools         AgentTool[]
  tasks         AgentTask[]

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())
  Faq       Faq[]

  @@map("agent")
}

model AgentMemory {
  id         String  @id @default(uuid())
  agentId    String
  agent      Agent   @relation(fields: [agentId], references: [id], onDelete: Cascade)
  type       String // 'short_term', 'long_term', 'knowledge_base'
  content    String  @db.Text
  embedding  String? @db.Text // JSON array for vector embeddings
  metadata   String? @db.Text // JSON metadata (tags, source, date, etc.)
  importance Int     @default(1) // 1-10 importance score

  createdAt DateTime @default(now())

  @@map("agent_memory")
}

model Conversation {
  id       String  @id @default(uuid())
  agentId  String
  agent    Agent   @relation(fields: [agentId], references: [id], onDelete: Cascade)
  userId   String
  user     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  title    String?
  summary  String? @db.Text
  isActive Boolean @default(true)

  messages      Message[]
  promptHistory PromptHistory[] // <-- Link to prompt history

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())
  Faq       Faq[]

  @@map("conversation")
}

model PromptHistory {
  id             String   @id @default(uuid())
  conversationId String
  prompt         String   @db.Text // The prompt text
  createdAt      DateTime @default(now())

  messages     Message[] // <-- Messages generated from this prompt
  Conversation Conversation @relation(fields: [conversationId], references: [id])
  Faq          Faq[]

  @@index([conversationId])
  @@map("prompt_history")
}

model AgentTool {
  id      String  @id @default(uuid())
  agentId String
  agent   Agent   @relation(fields: [agentId], references: [id], onDelete: Cascade)
  name    String // Tool name (e.g., "web_search", "calculator", "email_sender")
  type    String // 'api', 'function', 'system', 'plugin'
  config  String? @db.Text // JSON configuration for the tool
  enabled Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  @@map("agent_tool")
}

model AgentTask {
  id        String    @id @default(uuid())
  agentId   String
  agent     Agent     @relation(fields: [agentId], references: [id], onDelete: Cascade)
  name      String
  input     String?   @db.Text // JSON input data
  output    String?   @db.Text // JSON output result
  status    String    @default("pending") // 'pending', 'running', 'completed', 'failed'
  error     String?   @db.Text
  startedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  @@map("agent_task")
}

// Single Generic Junction Table for Entity-Label Relationships
model EntityLabel {
  id         String @id @default(uuid())
  entityId   String // ID of any entity (user, role, permission, etc.)
  entityType String // Type of entity (user, role, permission, token, etc.)
  labelId    String
  label      Label  @relation(fields: [labelId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([entityId, entityType, labelId])
  @@index([entityId, entityType])
  @@index([labelId])
  @@index([entityType])
  @@map("entity_label")
}

// Database Connection Management
model DatabaseConnection {
  id          String  @id @default(uuid())
  name        String  @unique
  description String? @db.Text
  type        String // 'mysql', 'postgresql', 'mongodb', 'sqlite'
  host        String
  port        Int     @default(3306)
  database    String
  username    String
  password    String // Should be encrypted in production

  // Connection options
  ssl     Boolean @default(false)
  timeout Int     @default(30000) // Connection timeout in milliseconds
  options String? @db.Text // JSON string for additional connection options

  // Status and monitoring
  isActive   Boolean   @default(true)
  lastTested DateTime?
  testStatus String? // 'success', 'failed', 'pending'
  testError  String?   @db.Text

  // Backup settings
  backupEnabled Boolean   @default(false)
  backupPath    String?
  lastBackup    DateTime?

  // Metadata
  createdBy String?
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  @@map("database_connection")
}

// Application Logs
model LogEntry {
  id           String   @id @default(uuid())
  level        String // 'error', 'warn', 'info', 'debug'
  message      String   @db.Text
  metadata     String?  @db.Text // JSON metadata
  userId       String?
  user         User?    @relation(fields: [userId], references: [id])
  ipAddress    String?
  userAgent    String?  @db.Text
  endpoint     String?
  method       String? // HTTP method
  statusCode   Int?
  responseTime Int? // Response time in milliseconds
  timestamp    DateTime @default(now())

  @@index([level])
  @@index([userId])
  @@index([timestamp])
  @@index([endpoint])
  @@map("log_entry")
}

model SocketConfig {
  id        String        @id @default(uuid())
  name      String
  host      String
  port      Int
  isActive  Boolean       @default(true)
  events    SocketEvent[]
  createdAt DateTime      @default(now())
  updatedAt DateTime      @default(now())

  @@map("socket_config")
}

model SocketEvent {
  id             String       @id @default(uuid())
  socketConfigId String
  type           String
  event          String
  socketConfig   SocketConfig @relation(fields: [socketConfigId], references: [id])
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @default(now())

  @@map("socket_event")
}

model File {
  id           String   @id @default(uuid())
  filename     String
  originalname String
  mimetype     String
  size         Int
  type         String   @default("document")
  path         String // <-- Add this line
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  User         User?    @relation(fields: [userId], references: [id])
  userId       String?
}

model UiConfig {
  id        String   @id @default(uuid())
  name      String   @unique
  value     String   @db.Text
  role      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("ui_config")
}

model Faq {
  id             String         @id @default(uuid())
  question       String         @db.Text
  answer         String         @db.Text
  type           String         @default("manual") // agent, doc_input, manual
  promptId       String?
  prompt         PromptHistory? @relation(fields: [promptId], references: [id])
  conversationId String?
  conversation   Conversation?  @relation(fields: [conversationId], references: [id])
  aiAgentId      String?
  agent          Agent?         @relation(fields: [aiAgentId], references: [id])
  messages       Message[]      // Link FAQ to messages (question/answer)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  description    String?

  @@map("faq")
}
