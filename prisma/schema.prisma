// AI Model table
model AIModel {
  id          String      @id @default(uuid())
  name        String      @unique
  description String?
  type        String // e.g. 'gpt', 'claude', 'gemini'
  platformId  String?
  platform    AIPlatform? @relation(fields: [platformId], references: [id])
  // Remove agentId and agent relation; AIModel is referenced by Agent
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  SSO         SSO[]
  Agent       Agent[]

  @@map("ai_model")
}

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum MessageType {
  question
  answer
}

// AI Platform Model
model AIPlatform {
  id           String         @id @default(uuid())
  name         String         @unique
  description  String?        @db.Text
  endpoint     String? // API endpoint URL
  apiKeys      AIKey[]
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  Agent        Agent[]
  Conversation Conversation[]
  models       AIModel[]

  @@map("ai_platform")
}

// AI Key Model
model AIKey {
  id           String         @id @default(uuid())
  key          String         @unique @db.VarChar(255)
  name         String
  description  String?        @db.Text
  userId       String?
  user         User?          @relation(fields: [userId], references: [id])
  platformId   String?
  platform     AIPlatform?    @relation(fields: [platformId], references: [id])
  isActive     Boolean        @default(true)
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  billing      Billing[]
  agents       AIKeyAgent[]
  Conversation Conversation[]

  @@map("ai_key")
}

// Join table for AIKey <-> Agent (many-to-many)
model AIKeyAgent {
  id        String   @id @default(uuid())
  aiKeyId   String
  agentId   String
  aiKey     AIKey    @relation(fields: [aiKeyId], references: [id], onDelete: Cascade)
  agent     Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([aiKeyId, agentId])
  @@map("ai_key_agent")
}

// Billing Model (linked to AIKey)
model Billing {
  id             String        @id @default(uuid())
  aiKeyId        String
  aiKey          AIKey         @relation(fields: [aiKeyId], references: [id], onDelete: Cascade)
  amount         Float
  currency       String        @default("USD")
  description    String?       @db.Text
  status         String        @default("pending") // pending, paid, failed
  paidAt         DateTime?
  conversationId String?
  conversation   Conversation? @relation(fields: [conversationId], references: [id])
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  @@map("billing")
}

model Category {
  id        String   @id @default(uuid())
  name      String   @unique
  blogs     Blog[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("category")
}

model Blog {
  id         String   @id @default(uuid())
  title      String
  content    String   @db.Text
  date       DateTime @default(now())
  categoryId String
  category   Category @relation(fields: [categoryId], references: [id])
  author     String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@map("blog")
}

model Label {
  id           String        @id @default(uuid())
  name         String        @unique
  color        String?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @default(now())
  description  String?
  entityLabels EntityLabel[]

  @@map("label")
}

model Notification {
  id           String                @id @default(uuid())
  message      String                @db.Text
  type         String? // info, error, warning, etc.
  templateId   String?
  template     NotificationTemplate? @relation(fields: [templateId], references: [id])
  errorPayload String?               @db.Text // JSON error payload
  userId       String?
  user         User?                 @relation(fields: [userId], references: [id])
  read         Boolean               @default(false)
  status       Int                   @default(1) // 1=active, 0=hidden/deleted
  createdAt    DateTime              @default(now())
  updatedAt    DateTime              @default(now())

  @@map("notification")
}

model Message {
  id              String         @id @default(uuid())
  conversationId  String
  conversation    Conversation   @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender          String // 'user', 'agent', 'system'
  content         String         @db.Text
  metadata        String?        @db.Text
  tokens          Int?
  position        Int            @default(0)
  agentId         String?
  isError         Boolean        @default(false)
  promptHistoryId String? // <-- Reference to PromptHistory
  promptHistory   PromptHistory? @relation(fields: [promptHistoryId], references: [id])
  type            MessageType    @default(question) // 'question' or 'answer'
  faqId           String?
  faq             Faq?           @relation(fields: [faqId], references: [id])
  createdAt       DateTime       @default(now())
  AgentMemory     AgentMemory[]

  @@index([conversationId, position])
  @@map("message")
}

model User {
  id            String         @id @default(uuid())
  email         String         @unique
  password      String
  nickname      String?
  roleId        String?
  role          Role?          @relation(fields: [roleId], references: [id])
  tokens        Token[]
  ssos          SSO[]
  loginHistory  LoginHistory[]
  logicHistory  LogicHistory[]
  apiKeys       ApiKey[] // API keys created by this user
  agents        Agent[] // AI agents owned by this user
  conversations Conversation[] // Conversations this user participated in
  logEntries    LogEntry[] // Log entries created by this user
  status        String         @default("active")
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  File          File[]
  Job           Job[]
  Notification  Notification[]
  AIKey         AIKey[]

  @@map("user")
}

model Role {
  id          String       @id @default(uuid())
  name        String       @unique
  description String?
  permissions Permission[]
  users       User[]
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @default(now())

  @@map("role")
}

model Permission {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?
  category    String   @default("other")
  route       String?
  method      String? // GET, POST, PUT, DELETE, PATCH
  roles       Role[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now())

  @@map("permission")
}

model Token {
  id               String   @id @default(uuid())
  userId           String
  accessToken      String   @unique @db.VarChar(500)
  refreshToken     String   @unique @db.VarChar(500)
  createdAt        DateTime @default(now())
  expiresAt        DateTime @default(now())
  refreshExpiresAt DateTime @default(now())
  user             User     @relation(fields: [userId], references: [id])

  @@map("token")
}

model MailTemplate {
  id        String   @id @default(uuid())
  name      String   @unique
  subject   String
  body      String   @db.Text
  active    Boolean  @default(true)
  mails     Mail[]
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  @@map("mail_template")
}

model NotificationTemplate {
  id           String         @id @default(uuid())
  name         String         @unique
  title        String
  body         String         @db.Text
  active       Boolean        @default(true)
  logicHistory LogicHistory[]
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @default(now())
  Notification Notification[]

  @@map("notification_template")
}

model Config {
  id    String @id @default(uuid())
  key   String @unique
  value String

  @@map("config")
}

model ApiKey {
  id          String  @id @default(uuid())
  name        String // Friendly name for the API key
  key         String  @unique @db.VarChar(255) // The actual API key
  description String? @db.Text
  userId      String? // Optional: associate with a user
  user        User?   @relation(fields: [userId], references: [id])

  // Access control
  isActive    Boolean @default(true)
  permissions String? @db.Text // JSON array of allowed permissions/scopes
  allowedIPs  String? @db.Text // JSON array of allowed IP addresses

  // Rate limiting
  rateLimit Int? @default(1000) // Requests per hour

  // Usage tracking
  usageCount Int       @default(0)
  lastUsedAt DateTime?

  // Expiration
  expiresAt DateTime?

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String? // User ID who created this API key

  // Usage logs
  apiUsageLogs ApiUsageLog[]

  @@map("api_key")
}

model ApiUsageLog {
  id       String @id @default(uuid())
  apiKeyId String
  apiKey   ApiKey @relation(fields: [apiKeyId], references: [id], onDelete: Cascade)

  // Request details
  endpoint  String // The API endpoint called
  method    String // HTTP method (GET, POST, etc.)
  ipAddress String?
  userAgent String? @db.Text

  // Response details
  statusCode   Int // HTTP status code
  responseTime Int? // Response time in milliseconds

  // Request/Response data (optional, for debugging)
  requestBody  String? @db.Text
  responseBody String? @db.Text

  // Metadata
  createdAt DateTime @default(now())

  @@map("api_usage_log")
}

model Mail {
  id           String        @id @default(uuid())
  to           String
  from         String?
  subject      String
  body         String        @db.Text
  status       String        @default("pending") // pending, sent, failed
  templateId   String?
  template     MailTemplate? @relation(fields: [templateId], references: [id])
  sentAt       DateTime?
  failedReason String?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @default(now())

  @@map("mail")
}

model SSO {
  id           String         @id @default(uuid())
  modelId      String?
  model        AIModel?       @relation(fields: [modelId], references: [id], onDelete: Cascade)
  url          String
  key          String         @unique
  ssoKey       String?        @unique // Additional SSO key field for identification
  userId       String
  deviceIP     String?
  loginHistory LoginHistory[]
  user         User           @relation(fields: [userId], references: [id])
  isActive     Boolean        @default(true)
  expiresAt    DateTime?
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @default(now())

  @@map("sso")
}

model LoginHistory {
  id        String    @id @default(uuid())
  ssoId     String?
  userId    String
  deviceIP  String?
  userAgent String?
  loginAt   DateTime  @default(now())
  logoutAt  DateTime?
  status    String    @default("active") // active, logged_out, expired
  location  String?
  sso       SSO?      @relation(fields: [ssoId], references: [id])
  user      User      @relation(fields: [userId], references: [id])
  createdAt DateTime  @default(now())
  updatedAt DateTime  @default(now())

  @@map("login_history")
}

model LogicHistory {
  id                     String                @id @default(uuid())
  userId                 String
  action                 String // login, logout, password_change, profile_update, etc.
  entityType             String? // user, role, permission, etc.
  entityId               String?
  oldValues              String?               @db.Text // JSON string of old values
  newValues              String?               @db.Text // JSON string of new values
  ipAddress              String?
  userAgent              String?
  notificationTemplateId String?
  notificationSent       Boolean               @default(false)
  user                   User                  @relation(fields: [userId], references: [id])
  notificationTemplate   NotificationTemplate? @relation(fields: [notificationTemplateId], references: [id])
  createdAt              DateTime              @default(now())

  @@map("logic_history")
}

// AI Agent Management Models
model Agent {
  id           String      @id @default(uuid())
  userId       String
  user         User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  name         String
  description  String?     @db.Text
  personality  String?     @db.Text // JSON config for personality
  systemPrompt String?     @db.Text
  config       String?     @db.Text // JSON config (temperature, max_tokens, etc.)
  isActive     Boolean     @default(true)
  platformId   String?
  platform     AIPlatform? @relation(fields: [platformId], references: [id])

  // Relationships
  memories      AgentMemory[]
  conversations Conversation[]
  tools         AgentTool[]
  tasks         AgentTask[]
  aiKeys        AIKeyAgent[]
  model         AIModel?       @relation(fields: [aIModelId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())
  Faq       Faq[]
  aIModelId String?

  @@map("agent")
}

model AgentMemory {
  id             String         @id @default(uuid())
  agentId        String
  agent          Agent          @relation(fields: [agentId], references: [id], onDelete: Cascade)
  promptId       String?
  prompt         PromptHistory? @relation(fields: [promptId], references: [id])
  conversationId String?
  conversation   Conversation?  @relation(fields: [conversationId], references: [id])
  messageId      String?
  message        Message?       @relation(fields: [messageId], references: [id])
  type           String // 'short_term', 'long_term', 'knowledge_base'
  content        String         @db.Text
  vectorId       String?        // <-- NEW: stores Redis vector key
  tokens         Int? // Token count for embedded message
  metadata       String?        @db.Text // JSON metadata (tags, source, date, etc.)
  importance     Int            @default(1) // 1-10 importance score
  createdAt      DateTime       @default(now())

  @@map("agent_memory")
}

model Conversation {
  id         String      @id @default(uuid())
  agentId    String
  agent      Agent       @relation(fields: [agentId], references: [id], onDelete: Cascade)
  userId     String
  user       User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  aiKeyId    String?
  aiKey      AIKey?      @relation(fields: [aiKeyId], references: [id])
  platformId String?
  platform   AIPlatform? @relation(fields: [platformId], references: [id])
  title      String?
  summary    String?     @db.Text
  isActive   Boolean     @default(true)

  messages      Message[]
  promptHistory PromptHistory[] // <-- Link to prompt history

  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @default(now())
  Faq             Faq[]
  JobConversation JobConversation[]
  Billing         Billing[]
  AgentMemory     AgentMemory[]

  @@map("conversation")
}

model PromptHistory {
  id             String   @id @default(uuid())
  conversationId String
  prompt         String   @db.Text // The prompt text
  createdAt      DateTime @default(now())

  messages     Message[] // <-- Messages generated from this prompt
  Conversation Conversation  @relation(fields: [conversationId], references: [id])
  Faq          Faq[]
  AgentMemory  AgentMemory[]

  @@index([conversationId])
  @@map("prompt_history")
}

model AgentTool {
  id      String  @id @default(uuid())
  agentId String
  agent   Agent   @relation(fields: [agentId], references: [id], onDelete: Cascade)
  name    String // Tool name (e.g., "web_search", "calculator", "email_sender")
  type    String // 'api', 'function', 'system', 'plugin'
  config  String? @db.Text // JSON configuration for the tool
  enabled Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  @@map("agent_tool")
}

model AgentTask {
  id        String    @id @default(uuid())
  agentId   String
  agent     Agent     @relation(fields: [agentId], references: [id], onDelete: Cascade)
  name      String
  input     String?   @db.Text // JSON input data
  output    String?   @db.Text // JSON output result
  status    String    @default("pending") // 'pending', 'running', 'completed', 'failed'
  error     String?   @db.Text
  startedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  @@map("agent_task")
}

// Single Generic Junction Table for Entity-Label Relationships
model EntityLabel {
  id         String @id @default(uuid())
  entityId   String // ID of any entity (user, role, permission, etc.)
  entityType String // Type of entity (user, role, permission, token, etc.)
  labelId    String
  label      Label  @relation(fields: [labelId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([entityId, entityType, labelId])
  @@index([entityId, entityType])
  @@index([labelId])
  @@index([entityType])
  @@map("entity_label")
}

// Database Connection Management
model DatabaseConnection {
  id          String  @id @default(uuid())
  name        String  @unique
  description String? @db.Text
  type        String // 'mysql', 'postgresql', 'mongodb', 'sqlite'
  host        String
  port        Int     @default(3306)
  database    String
  username    String
  password    String // Should be encrypted in production

  // Connection options
  ssl     Boolean @default(false)
  timeout Int     @default(30000) // Connection timeout in milliseconds
  options String? @db.Text // JSON string for additional connection options

  // Status and monitoring
  isActive   Boolean   @default(true)
  lastTested DateTime?
  testStatus String? // 'success', 'failed', 'pending'
  testError  String?   @db.Text

  // Backup settings
  backupEnabled Boolean   @default(false)
  backupPath    String?
  lastBackup    DateTime?

  // Metadata
  createdBy   String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @default(now())
  JobDatabase JobDatabase[]

  @@map("database_connection")
}

// Application Logs
model LogEntry {
  id           String   @id @default(uuid())
  level        String // 'error', 'warn', 'info', 'debug'
  message      String   @db.Text
  metadata     String?  @db.Text // JSON metadata
  userId       String?
  user         User?    @relation(fields: [userId], references: [id])
  ipAddress    String?
  userAgent    String?  @db.Text
  endpoint     String?
  method       String? // HTTP method
  statusCode   Int?
  responseTime Int? // Response time in milliseconds
  timestamp    DateTime @default(now())

  @@index([level])
  @@index([userId])
  @@index([timestamp])
  @@index([endpoint])
  @@map("log_entry")
}

model SocketConfig {
  id        String        @id @default(uuid())
  name      String
  host      String
  port      Int
  isActive  Boolean       @default(true)
  events    SocketEvent[]
  createdAt DateTime      @default(now())
  updatedAt DateTime      @default(now())

  @@map("socket_config")
}

model SocketEvent {
  id             String       @id @default(uuid())
  socketConfigId String
  type           String
  event          String
  socketConfig   SocketConfig @relation(fields: [socketConfigId], references: [id])
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @default(now())

  @@map("socket_event")
}

model File {
  id           String        @id @default(uuid())
  filename     String
  originalname String
  mimetype     String
  size         Int
  type         String        @default("document")
  path         String
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @default(now())
  User         User?         @relation(fields: [userId], references: [id])
  userId       String?
  JobDocument  JobDocument[]
  Document     Document?
}

model Document {
  id        String   @id @default(uuid())
  fileId    String   @unique
  file      File     @relation(fields: [fileId], references: [id], onDelete: Cascade)
  name      String?
  url       String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  job       Job?     @relation(fields: [jobId], references: [id])
  jobId     String?  @unique

  @@map("document")
}

model UiConfig {
  id        String   @id @default(uuid())
  name      String   @unique
  value     String   @db.Text
  role      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  @@map("ui_config")
}

model Faq {
  id             String         @id @default(uuid())
  question       String         @db.Text
  answer         String         @db.Text
  type           String         @default("manual") // agent, doc_input, manual
  promptId       String?
  prompt         PromptHistory? @relation(fields: [promptId], references: [id])
  conversationId String?
  conversation   Conversation?  @relation(fields: [conversationId], references: [id])
  aiAgentId      String?
  agent          Agent?         @relation(fields: [aiAgentId], references: [id])
  messages       Message[] // Link FAQ to messages (question/answer)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  description    String?

  @@map("faq")
}

model Job {
  id          String    @id @default(uuid())
  type        String    @default("backup") // backup, fine-tuning, extract, document, database, conversation, etc.
  status      String    @default("pending") // pending, running, completed, failed
  payload     String?   @db.Text // JSON string for job data
  result      String?   @db.Text // JSON string for job result/output
  error       String?   @db.Text
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  startedAt   DateTime?
  finishedAt  DateTime?
  description String?
  userId      String?
  user        User?     @relation(fields: [userId], references: [id])

  // Link to at least one conversation
  conversations JobConversation[]

  // Link to at least one document
  documents JobDocument[]

  // Link to at least one database
  databases JobDatabase[]

  document Document?

  @@map("job")
}

// Junction table for Job <-> Conversation (many-to-many)
model JobConversation {
  id             String       @id @default(uuid())
  jobId          String
  conversationId String
  job            Job          @relation(fields: [jobId], references: [id], onDelete: Cascade)
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  createdAt      DateTime     @default(now())

  @@unique([jobId, conversationId])
  @@index([jobId])
  @@index([conversationId])
  @@map("job_conversation")
}

// Blog and Category Models
// Junction table for Job <-> Document (many-to-many)
model JobDocument {
  id         String   @id @default(uuid())
  jobId      String
  documentId String
  job        Job      @relation(fields: [jobId], references: [id], onDelete: Cascade)
  document   File     @relation(fields: [documentId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())

  @@unique([jobId, documentId])
  @@index([jobId])
  @@index([documentId])
  @@map("job_document")
}

// Junction table for Job <-> Database (many-to-many)
model JobDatabase {
  id         String             @id @default(uuid())
  jobId      String
  databaseId String
  job        Job                @relation(fields: [jobId], references: [id], onDelete: Cascade)
  database   DatabaseConnection @relation(fields: [databaseId], references: [id], onDelete: Cascade)
  createdAt  DateTime           @default(now())

  @@unique([jobId, databaseId])
  @@index([jobId])
  @@index([databaseId])
  @@map("job_database")
}
